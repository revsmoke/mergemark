<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MergeMark - Combined Document to PDF</title>
    <style>
     /* CSS Styles with consistent spacing */
:root {
  --primary-color: #1a365d;
  --secondary-color: #2c5282;
  --accent-color: #4299e1;
  --danger-color: #e53e3e;
  --warning-color: #dd6b20;
  --text-color: #2d3748;
  --light-gray: #e2e8f0;
  --very-light-gray: #f8fafc;
  --border-radius: 6px;
  --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  --transition: all 0.3s ease;
  /* Adding standard spacing variables */
  --spacing-xs: 0.5rem;
  --spacing-sm: 1rem;
  --spacing-md: 1.5rem;
  --spacing-lg: 2rem;
  --spacing-xl: 3rem;
  --max-content-width: 900px;
  --container-padding: var(--spacing-lg);
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.8;
  color: var(--text-color);
  background-color: var(--very-light-gray);
  margin: 0;
  padding: 0 0 0 0;
}

.container {
  max-width: var(--max-content-width);
  margin: 0 auto;
}

nav {
  max-width: var(--max-content-width);
  margin: 0 auto;
  background-color: white;
  color: var(--primary-color);
  padding: var(--spacing-lg);
  display: flex;
  justify-content: space-between;
  align-items: center;
  position: sticky;
  top: 0;
  z-index: 1000;
  border-bottom: 1px solid var(--light-gray);
  box-shadow: var(--box-shadow);
}

nav ul {
  display: flex;
  list-style: none;
  gap: var(--spacing-sm);
  margin: 0;
  padding: 0;
}

ul li, ol li {
  margin-right: var(--spacing-sm);
  margin-left: var(--spacing-sm);
}

h1 {
  font-size: 2rem;
  color: var(--primary-color);
  margin: var(--spacing-lg) 0;
  font-weight: 500;
  letter-spacing: 1px;
  page-break-before: avoid;
}

h2 {
  font-size: 1.5rem;
  color: var(--secondary-color);
  border-bottom: 2px solid var(--accent-color);
  padding-bottom: var(--spacing-sm);
  margin-top: var(--spacing-xl);
  font-weight: 400;
  page-break-after: avoid;
}

h3 {
  color: var(--primary-color);
  font-size: 1.2rem;
  margin-bottom: var(--spacing-sm);
  margin-top: var(--spacing-md);
}

a {
  font-size: 1rem;
  color: var(--secondary-color);
}

pre {
  white-space: pre-wrap;
  word-wrap: break-word;
  background-color: #fff;
  padding: var(--spacing-md);
  border-radius: var(--border-radius);
  border: 1px solid var(--light-gray);
  box-shadow: var(--box-shadow);
  font-family: "Courier New", monospace;
  font-size: 0.9rem;
  line-height: 1.6;
  color: #2d3748;
  page-break-inside: avoid;
  margin: var(--spacing-md) 0;
}

table {
  width: 100%;
  border-collapse: collapse;
  margin: var(--spacing-sm) 0;
}

table th,
table td {
  border: 1px solid var(--light-gray);
  padding: var(--spacing-xs);
  text-align: left;
}

dialog {
  margin: auto;
  background-color: white;
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  width: 450px;
  max-width: 90%;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  text-align: center;
  position: relative;
}

footer {
  text-align: center;
  padding: var(--spacing-sm);
  background-color: white;
  border-top: 1px solid var(--light-gray);
  max-width: var(--max-content-width);
  margin: var(--spacing-xl) auto;
}

#intro {
  margin-bottom: var(--spacing-sm);
  padding: var(--spacing-sm);
  background-color: white;
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  border: 1px solid var(--light-gray);
}

.file-section {
  margin-bottom: var(--spacing-xl);
  padding: var(--spacing-md);
  background-color: white;
  border-radius: var(--border-radius);
  box-shadow: none;
  transition: var(--transition);
  page-break-inside: avoid;
}

.file-section:hover {
  box-shadow: 0 10px 15px rgba(0, 0, 0, 0.1);
}

.file-section h2 {
  margin-top: var(--spacing-sm);
  margin-bottom: var(--spacing-sm);
  text-transform: uppercase;
}

.file-section h2 a {
  text-transform: lowercase;
}

.file-section img {
  max-width: 100%;
  height: auto;
  margin-bottom: var(--spacing-sm);
}

.controls {
  background-color: white;
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  border: 1px solid var(--light-gray);
  box-shadow: var(--box-shadow);
  margin-bottom: var(--spacing-lg);
  display: flex;
  flex-wrap: wrap;
  gap: var(--spacing-sm);
  align-items: center;
}

.button {
  background-color: var(--accent-color);
  color: white;
  border: none;
  padding: var(--spacing-sm) var(--spacing-lg);
  font-size: 1rem;
  border-radius: var(--border-radius);
  cursor: pointer;
  transition: var(--transition);
  font-weight: 500;
  letter-spacing: 0.5px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.button:hover:not(:disabled) {
  background-color: var(--secondary-color);
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
}

.button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.button.danger {
  background-color: var(--danger-color);
}

.button.danger:hover:not(:disabled) {
  background-color: #c53030;
}

.button.warning {
  background-color: var(--warning-color);
}

.button.warning:hover:not(:disabled) {
  background-color: #b75c1d;
}

.file-input-container {
  display: inline-block;
  position: relative;
}

.file-input-label {
  background-color: white;
  color: var(--secondary-color);
  border: 2px solid var(--accent-color);
  padding: var(--spacing-xs) var(--spacing-md);
  border-radius: var(--border-radius);
  cursor: pointer;
  display: inline-block;
  transition: var(--transition);
  font-weight: 500;
}

.file-input-label:hover {
  background-color: var(--accent-color);
  color: white;
}

#fileInput {
  position: absolute;
  left: -9999px;
}

#reorderContainer {
  display: none;
}

.drop-zone {
  border: 3px dashed var(--light-gray);
  padding: var(--spacing-lg);
  text-align: center;
  color: var(--secondary-color);
  margin-top: var(--spacing-sm);
  border-radius: var(--border-radius);
  transition: var(--transition);
  background-color: #fff;
  flex-basis: 100%;
  order: 3;
}

.drop-zone.drag-over-page {
  border-color: var(--accent-color);
  background-color: rgba(66, 153, 225, 0.05);
}

.document-section-reorder-container {
  margin: var(--spacing-lg) 0;
  background-color: white;
  padding: var(--spacing-md);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  border: 1px solid var(--light-gray);
}

#reorderPlaceholder {
  color: #718096;
  font-style: italic;
  text-align: center;
  padding: var(--spacing-sm);
}

#document-section-reorder-list {
  list-style: decimal;
  padding-left: var(--spacing-md);
  margin-top: var(--spacing-sm);
}

#document-section-reorder-list li {
  padding: var(--spacing-sm);
  border: 1px solid var(--light-gray);
  border-radius: var(--border-radius);
  margin-bottom: var(--spacing-xs);
  cursor: move;
  background: white;
  transition: var(--transition);
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
  display: flex;
  justify-content: space-between;
  align-items: center;
  outline: none;
}

#document-section-reorder-list li:focus-visible {
  box-shadow: 0 0 0 2px var(--accent-color);
  border-color: var(--accent-color);
}

#document-section-reorder-list li:hover {
  background-color: var(--very-light-gray);
  border-color: var(--accent-color);
}

#document-section-reorder-list li.dragging {
  opacity: 0.5;
  background: var(--light-gray);
}

#document-section-reorder-list li.drag-over {
  border-top: 2px solid var(--accent-color);
}

.delete-btn {
  background-color: var(--danger-color);
  color: white;
  border: none;
  padding: var(--spacing-xs) var(--spacing-sm);
  border-radius: 4px;
  cursor: pointer;
  transition: var(--transition);
  font-size: 0.85rem;
  margin-left: var(--spacing-sm);
}

.delete-btn:hover {
  background-color: #c53030;
}

.modal-content {
  margin: auto;
  background-color: white;
  padding: var(--spacing-lg);
  border-radius: var(--border-radius);
  width: 450px;
  max-width: 90%;
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
  text-align: center;
}

.modal-title {
  color: var(--primary-color);
  margin-top: 0;
  font-size: 1.4rem;
}

.modal-message {
  margin: var(--spacing-sm) 0;
  line-height: 1.6;
}

.modal-actions {
  margin-top: var(--spacing-md);
  display: flex;
  justify-content: center;
  gap: var(--spacing-sm);
}

.modal-close {
  background-color: var(--light-gray);
  color: var(--text-color);
  position: absolute;
  top: 0.5rem;
  right: 0.5rem;
  border-radius: var(--border-radius);
  padding: var(--spacing-xs) var(--spacing-sm);
}

.modal-cancel {
  background-color: var(--light-gray);
  color: var(--text-color);
}

.modal-cancel:hover {
  background-color: #cbd5e0;
}

.modal-confirm.delete {
  background-color: var(--danger-color);
}

.modal-confirm.delete:hover {
  background-color: #c53030;
}

.modal-confirm.clear {
  background-color: var(--warning-color);
}

.modal-confirm.clear:hover {
  background-color: #b75c1d;
}

.help-details {
  margin-top: var(--spacing-xl);
}

.help-details summary {
  cursor: pointer;
  font-weight: 500;
  color: var(--secondary-color);
  padding: var(--spacing-xs);
  border-radius: var(--border-radius);
  background-color: white;
  box-shadow: var(--box-shadow);
  display: inline-block;
  border: 1px solid var(--light-gray);
  width: 100%;
}

.help-details summary:hover {
  background-color: var(--light-gray);
}

.help-container {
  container-type: inline-size;
  container-name: help-container;
  background-color: white;
  padding: var(--spacing-md);
  margin-top: var(--spacing-xs);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  border: 1px solid var(--light-gray);
  font-size: 0.95rem;
}

.help-container h2 {
  font-size: 1.4rem;
  margin-top: var(--spacing-lg);
}

.help-container .tip-box,
.help-container .use-case {
  background-color: var(--very-light-gray);
  border-left: 3px solid var(--accent-color);
  padding: var(--spacing-xs) var(--spacing-sm);
  margin: var(--spacing-xs) 0;
  border-radius: 4px;
}

.help-container .tip-title {
  font-weight: bold;
  color: var(--primary-color);
}

.help-container .footer {
  text-align: center;
  margin-top: var(--spacing-lg);
  font-size: 0.85rem;
  color: #718096;
}

.loading-indicator {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid rgba(255, 255, 255, 0.3);
  border-radius: 50%;
  border-top-color: #fff;
  animation: spin 1s ease-in-out infinite;
  margin-left: 8px;
  vertical-align: middle;
}

.loading-indicator-container {
  display: inline-flex;
  align-items: center;
  gap: var(--spacing-xs);
  color: var(--secondary-color);
  font-weight: 500;
}

@keyframes spin {
  to {
    transform: rotate(360deg);
  }
}

@container help-container (max-width: 600px) {
  .help-container {
    font-size: 0.85rem;
  }
}

@media print {
  /* Print styles remain relevant for potential browser printing */
  body {
    margin: 0;
    padding: 1.5cm;
    background-color: white;
    font-size: 11pt;
    color: black;
  }
  .no-print {
    display: none !important;
  }
  .container {
    max-width: 100%;
    padding: 0;
  }
  h1 {
    font-size: 20pt;
    color: black;
    text-align: left;
    margin: 0 0 1cm 0;
  }
  h2 {
    font-size: 16pt;
    margin-top: 1cm;
    page-break-after: avoid;
    color: black;
    border-bottom: 1px solid #aaa;
    padding-bottom: 0.3cm;
  }
  pre {
    background-color: #fdfdfd;
    border: 1px solid #ddd;
    box-shadow: none;
    font-size: 9pt;
    margin: 0.5cm 0;
    padding: 0.5cm;
    page-break-inside: avoid;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  .file-section {
    margin-bottom: 1cm;
    padding: 0;
    border: none;
    box-shadow: none;
    page-break-inside: avoid;
    background-color: white;
  }
  .file-section:hover {
    border: none;
  }
  a,
  a:visited {
    color: #3366cc;
    text-decoration: underline;
  }
  img {
    max-width: 100%;
    height: auto;
  }
}

/* Add styles for error reporting */
.error-container {
  margin-bottom: var(--spacing-lg);
  padding: var(--spacing-md);
  background-color: #fed7d7; /* Light red background */
  border: 1px solid var(--danger-color);
  border-radius: var(--border-radius);
  color: #9b2c2c; /* Darker red text */
}

.error-container:empty {
  display: none; /* Hide if empty */
}

.error-message {
  margin-bottom: var(--spacing-xs);
  font-size: 0.9rem;
  line-height: 1.5;
}

.error-message:last-child {
  margin-bottom: 0;
}
/* End error styles */
    </style>
    <script src="https://kit.fontawesome.com/c3c35d722d.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <nav>
      <img id="logo" src="mergemark_logo.svg" alt="MergeMark Logo" style="width: 50px; height: auto;"> 
      <ul>
        <li><a href="https://mergemark.app">MergeMark</a></li>
        <li><a href="#helpDetails" id="helpLink">Help</a></li>
        <li><a id="contactLink" href="https://mergemark.app/contact">Contact</a></li>
      </ul>
    </nav>
    <div class="container">
      <h1>MergeMark</h1>
      <p id="intro" class="no-print">
        MergeMark combines multiple text or markdown files into a single PDF
        containing the extracted text.
      </p>

      <div class="controls no-print">
        <div class="file-input-container">
          <label for="fileInput" class="file-input-label">Select Files</label>
          <input
            type="file"
            id="fileInput"
            multiple
            accept=".txt,.md,text/plain,text/markdown"
          />
        </div>
        <button id="printButton" class="button" disabled>Print Document</button>
        <button id="generateButton" class="button" disabled>
          Generate PDF (Text Only)
        </button>
        <button id="exportHtmlButton" class="button" disabled>Export Combined HTML</button>
        <button id="exportMdButton" class="button" disabled>Export Combined Markdown</button>
        <button id="clearAllButton" class="button warning" disabled>
          Clear All
        </button>
        <div id="dropZone" class="drop-zone no-print">
          Drag & Drop Text or Markdown Files Here
        </div>
        <div
          id="loadingIndicator"
          class="loading-indicator-container no-print"
          style="display: none"
        >
          <span>Generating PDF...</span>
          <span class="loading-indicator"></span>
        </div>
      </div>

      <!-- Add Error Message Container -->
      <div id="errorMessages" class="error-container no-print"></div>
      <!-- End Error Message Container -->

      <div
        id="reorderContainer"
        class="document-section-reorder-container no-print"
      >
        <h3>Document Sections (Drag to Reorder)</h3>
        <div id="reorderPlaceholder">
          Upload or drop files to see sections here.
        </div>
        <ol id="document-section-reorder-list"></ol>
      </div>

      <main id="content"></main>
  
      <details id="helpDetails" class="no-print help-details">
        <summary>Help / Instructions</summary>
        <div class="help-container">
          <h2>Getting Started with MergeMark</h2>
          <p>
            Combine multiple text (.txt) or markdown (.md) files into a single
            PDF.
          </p>
          <ol>
            <li>
              <strong>Upload Files:</strong> Click "Select Files" or drag & drop
              files.
            </li>
            <li>
              <strong>Reorder Content:</strong> Drag and drop items in the list
              to change their order.
            </li>
            <li>
              <strong>Remove Content:</strong> Click the "Delete" button next to
              any section.
            </li>
            <li>
              <strong>Clear All:</strong> Click "Clear All" to remove all files.
            </li>
            <li>
              <strong>Generate PDF (Text Only):</strong> Click this button to
              create a PDF containing the plain text from each section. The PDF
              will download automatically. **Note:** Formatting like bold text,
              lists, and heading styles seen on screen will *not* be preserved
              in this PDF version.
            </li>
          </ol>
          <h2>Tips</h2>
          <div class="tip-box">
            <div class="tip-title">Markdown Support:</div>
            Preview shows formatted markdown, but PDF export is text only.
          </div>
          <div class="tip-box">
            <div class="tip-title">Text Files:</div>
            Text content is included in the PDF.
          </div>
          <div class="tip-box">
            <div class="tip-title">PDF Output:</div>
            The generated PDF uses standard fonts and basic layout for
            readability.
          </div>
          <footer class="footer">© 2025 MergeMark</footer>
        </div>
      </details>
    </div>

    <dialog id="confirmationModal" class="modal no-print">
      <button id="closeConfirmationModal" class="modal-close"><i class="fas fa-times"></i></button>
      <div>
        <h3 id="modalTitle" class="modal-title">Confirm Action</h3>
        <p id="modalMessage" class="modal-message">Are you sure?</p>
        <div class="modal-actions">
          <button id="cancelBtn" class="button modal-cancel">Cancel</button>
          <button id="confirmBtn" class="button modal-confirm">Confirm</button>
        </div>
      </div>
    </dialog>

    <dialog id="contactDialog" class="modal no-print">
      <button id="closeContactDialog" class="modal-close"><i class="fas fa-times"></i></button>
      <div>
        <h3 id="modalTitle" class="modal-title">Contact Us</h3>
        <p id="modalMessage" class="modal-message">Please fill out the form below to contact us.</p>
        <!-- Add Contact Form -->
        <form id="contactForm" style="text-align: left; margin-top: var(--spacing-md);">
          <div style="margin-bottom: var(--spacing-sm);">
            <label for="contactName" style="display: block; margin-bottom: var(--spacing-xs); font-weight: 500;">Name:</label>
            <input type="text" id="contactName" name="contactName" required style="width: 100%; padding: var(--spacing-xs); border: 1px solid var(--light-gray); border-radius: var(--border-radius);">
          </div>
          <div style="margin-bottom: var(--spacing-sm);">
            <label for="contactEmail" style="display: block; margin-bottom: var(--spacing-xs); font-weight: 500;">Email:</label>
            <input type="email" id="contactEmail" name="contactEmail" required style="width: 100%; padding: var(--spacing-xs); border: 1px solid var(--light-gray); border-radius: var(--border-radius);">
          </div>
          <div style="margin-bottom: var(--spacing-sm);">
            <label for="contactSubject" style="display: block; margin-bottom: var(--spacing-xs); font-weight: 500;">Subject:</label>
            <input type="text" id="contactSubject" name="contactSubject" required style="width: 100%; padding: var(--spacing-xs); border: 1px solid var(--light-gray); border-radius: var(--border-radius);">
          </div>
          <div style="margin-bottom: var(--spacing-md);">
            <label for="contactMessage" style="display: block; margin-bottom: var(--spacing-xs); font-weight: 500;">Message:</label>
            <textarea id="contactMessage" name="contactMessage" rows="4" required style="width: 100%; padding: var(--spacing-xs); border: 1px solid var(--light-gray); border-radius: var(--border-radius); resize: vertical;"></textarea>
          </div>
          <div style="text-align: right;">
            <button type="submit" class="button">Send Message</button>
          </div>
        </form>
        <!-- End Contact Form -->
      </div>
    </dialog>
    <footer>
      <p>© 2025 MergeMark</p>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
      integrity="sha512-qZvrmS2ekKPF2mSznTQsxqPgnpkI4DNTlrdUmTzrDgektczlKNRRhy5X5AAOnx5S09ydFYWWNSfcEqDTTHgtNA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.35/jspdf.plugin.autotable.min.js"></script>
    <script src="js/html2canvas.min.js"></script>
    <script defer>
      document.addEventListener("DOMContentLoaded", function () {
        // --- DOM Elements ---
        const fileInput = document.getElementById("fileInput");
        const contentContainer = document.getElementById("content");
        const generateButton = document.getElementById("generateButton");
        const printButton = document.getElementById("printButton");
        const clearAllButton = document.getElementById("clearAllButton");
        const exportHtmlButton = document.getElementById("exportHtmlButton");
        const exportMdButton = document.getElementById("exportMdButton");
        const reorderList = document.getElementById(
          "document-section-reorder-list"
        );
        const reorderContainer = document.getElementById("reorderContainer");
        const reorderPlaceholder =
          document.getElementById("reorderPlaceholder");
        const confirmationModal = document.getElementById("confirmationModal");
        const modalTitle = confirmationModal.querySelector(".modal-title");
        const modalMessage = confirmationModal.querySelector(".modal-message");
        const confirmBtn = document.getElementById("confirmBtn");
        const cancelBtn = document.getElementById("cancelBtn");
        const closeConfirmationModal = document.getElementById("closeConfirmationModal");
        const dropZone = document.getElementById("dropZone");
        const loadingIndicator = document.getElementById("loadingIndicator");
        const loadingIndicatorText = loadingIndicator.querySelector('span:first-child');
        const contactDialog = document.getElementById("contactDialog");
        const closeContactDialog = document.getElementById("closeContactDialog");
        const contactLink = document.getElementById("contactLink");
        const helpLink = document.getElementById("helpLink");
        const helpDetails = document.getElementById("helpDetails");
        const errorMessagesContainer = document.getElementById("errorMessages");

        // --- State Variables ---
        let draggedLi = null;
        let sectionCounter = 0;
        let pendingAction = null;
        let itemToDelete = null;

        // --- Utility Functions ---
        function showLoading(isLoading, actionText = "Processing...") {
          loadingIndicatorText.textContent = actionText;
          loadingIndicator.style.display = isLoading ? "inline-flex" : "none";
          generateButton.disabled = isLoading;
          printButton.disabled = isLoading;
          clearAllButton.disabled = isLoading;
          exportHtmlButton.disabled = isLoading;
          exportMdButton.disabled = isLoading;
          fileInput.disabled = isLoading;
          reorderList.style.pointerEvents = isLoading ? "none" : "auto";
          reorderList.style.opacity = isLoading ? 0.7 : 1;
        }
        function updateUIState() {
          const hasFiles = reorderList.children.length > 0;
          reorderContainer.style.display = "block";
          reorderPlaceholder.style.display = hasFiles ? "none" : "block";
          reorderList.style.display = hasFiles ? "block" : "none";
          generateButton.disabled = !hasFiles;
          clearAllButton.disabled = !hasFiles;
          printButton.disabled = !hasFiles;
          exportHtmlButton.disabled = !hasFiles;
          exportMdButton.disabled = !hasFiles;
        }

        function clearErrors() {
          errorMessagesContainer.innerHTML = '';
          errorMessagesContainer.style.display = 'none';
        }

        function displayError(message) {
          const errorElement = document.createElement('p');
          errorElement.className = 'error-message';
          errorElement.textContent = message;
          errorMessagesContainer.appendChild(errorElement);
          errorMessagesContainer.style.display = 'block';
          console.error("Error Displayed: ", message);
        }

        // --- NEW Image Handling Helpers ---

        // Fetches an image URL and converts it to a Base64 Data URL
        async function fetchImageAsBase64(url) {
            try {
                // Basic check for existing data URLs
                if (url.startsWith('data:image')) {
                    return url;
                }

                // Add timestamp to try bypassing cache if needed, though browser cache might still interfere
                // const cacheBusterUrl = url + (url.includes('?') ? '&' : '?') + '_=' + Date.now();

                const response = await fetch(url); // Use default cache behavior first

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} for URL: ${url}`);
                }
                const blob = await response.blob();

                // Ensure it's an image blob
                if (!blob.type.startsWith('image/')) {
                    throw new Error(`Fetched resource is not an image type (${blob.type}) for URL: ${url}`);
                }

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = (error) => reject(new Error(`FileReader error for URL ${url}: ${error}`));
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                 // Log specific error but re-throw or return an indicator
                console.error(`Failed to fetch or convert image ${url}:`, error);
                 displayError(`Could not load image: ${url}. Reason: ${error.message}. It might be blocked by CORS or unavailable.`);
                return null; // Return null to indicate failure
            }
        }

        // Finds images within an element and updates their src to Base64
        async function processImagesInElement(element) {
            const images = element.querySelectorAll('img');
            const promises = [];

            images.forEach(img => {
                const originalSrc = img.getAttribute('src');
                 if (originalSrc && !originalSrc.startsWith('data:image')) {
                    // Create a promise for each image conversion
                     const promise = fetchImageAsBase64(originalSrc).then(base64Url => {
                        if (base64Url) {
                             img.src = base64Url; // Update the src attribute directly
                         } else {
                             // Optional: Handle failed images (e.g., show placeholder, remove img)
                             img.alt = `(Failed to load: ${img.alt || originalSrc})`;
                             // img.style.display = 'none'; // Or hide it
                         }
                    });
                    promises.push(promise);
                 }
            });

            // Wait for all image conversions for this element to settle
            await Promise.allSettled(promises);
         }

        // --- File Handling (Modified) ---
        function processFiles(files) {
          showLoading(true, "Loading & Processing Files..."); // Updated text
          clearErrors();

          contentContainer.innerHTML = "";
          reorderList.innerHTML = "";
          sectionCounter = 0;
          let fileArray = Array.from(files);
          const skippedFiles = [];
          const validFiles = fileArray.filter(file => {
                const isValid = file.type === "text/plain" ||
                       file.type === "text/markdown" ||
                       file.name.toLowerCase().endsWith(".txt") ||
                       file.name.toLowerCase().endsWith(".md");
                if (!isValid) {
                    skippedFiles.push(file.name);
                }
                return isValid;
           });
           if (skippedFiles.length > 0) { 
               displayError(`Skipped ${skippedFiles.length} file(s) due to invalid type (only .txt or .md allowed): ${skippedFiles.join(', ')}`);
            }
           if (validFiles.length === 0) { 
                showLoading(false);
                updateUIState();
                return;
            }
          // Clear containers before processing starts
          contentContainer.innerHTML = ""; 
          reorderList.innerHTML = "";
          sectionCounter = 0;

           validFiles.sort((a, b) => a.name.localeCompare(b.name));
           // let filesProcessed = 0; // Replaced by Promise tracking
           const allFileProcessingPromises = []; // Array to hold promises for each file's processing

          validFiles.forEach((file) => {
            // Wrap the entire file processing in a promise
             const filePromise = new Promise(async (resolveFile, rejectFile) => {
                 const reader = new FileReader();

                 reader.onload = async function (e) { // Make onload async
                    const sectionId = "section_" + sectionCounter++; // Generate ID early for potential error cleanup
                    try {
                        const fileContent = e.target.result;
                        const section = document.createElement("section");
                        section.className = "file-section";
                        section.id = sectionId;
                        section.dataset.rawContent = fileContent;
                        section.dataset.fileName = file.name;

                        const header = document.createElement("h2");
                        header.textContent = file.name;
                        section.appendChild(header);

                        let contentElement; // To hold the div or pre

                        if (file.name.toLowerCase().endsWith(".md")) {
                            const contentDiv = document.createElement("div");
                            contentDiv.innerHTML = marked.parse(fileContent); // Initial parse
                            section.appendChild(contentDiv);
                            contentElement = contentDiv;

                            // --> Process images AFTER initial parse
                             showLoading(true, `Processing images in ${file.name}...`); // Give feedback
                            await processImagesInElement(contentDiv);
                             showLoading(true, "Loading & Processing Files..."); // Reset loading text
                            // <-- End image processing

                        } else {
                            const pre = document.createElement("pre");
                            pre.textContent = fileContent;
                            section.appendChild(pre);
                            contentElement = pre;
                        }
                        contentContainer.appendChild(section);

                        // Create list item... 
                        const li = document.createElement("li");
                        li.setAttribute("data-section-id", sectionId);
                        li.setAttribute("draggable", true);
                        li.setAttribute("tabindex", "0");
                        const fileNameSpan = document.createElement("span");
                        fileNameSpan.textContent = file.name;
                        fileNameSpan.style.overflow = "hidden";
                        fileNameSpan.style.textOverflow = "ellipsis";
                        fileNameSpan.style.whiteSpace = "nowrap";
                        fileNameSpan.style.marginRight = "10px";
                        const deleteBtn = document.createElement("button");
                        deleteBtn.className = "delete-btn";
                        deleteBtn.textContent = "Delete";
                        deleteBtn.type = "button";
                        deleteBtn.addEventListener("click", (event) => {
                          event.stopPropagation();
                          showConfirmation("delete", { sectionId: sectionId, fileName: file.name });
                        });
                        li.appendChild(fileNameSpan);
                        li.appendChild(deleteBtn);
                        addLiDragAndDropHandlers(li);
                        reorderList.appendChild(li);
                        resolveFile(); // Resolve the promise for this file

                    } catch (error) {
                         displayError(`Error processing file "${file.name}": ${error.message}`);
                         const problemSection = document.getElementById(sectionId);
                         if (problemSection) problemSection.remove();
                         // Don't remove LI here as it might not exist yet
                         rejectFile(error); // Reject the promise for this file
                     }
                 };

                 reader.onerror = function (e) {
                     const errorMsg = `Error reading file "${file.name}". Details: ${e.target.error || 'Unknown read error'}`;
                     displayError(errorMsg);
                     rejectFile(new Error(errorMsg)); // Reject the promise for this file
                 };

                 reader.readAsText(file);
             }); // End of filePromise

            allFileProcessingPromises.push(filePromise);

          }); // End loop through validFiles

          // Wait for all files to be processed (including image conversion)
          Promise.allSettled(allFileProcessingPromises).then(() => {
              showLoading(false);
              updateSectionsOrderFromList(); // Update order based on LI elements
              updateUIState();
              console.log("All files processed.");
           }).catch(error => {
              // This catch might be redundant if individual errors are handled, but good for safety
              console.error("Error during batch file processing:", error);
              showLoading(false); // Ensure loading is hidden on batch error
              updateUIState();
          });
        } // End processFiles function

        // --- Reordering Logic (No changes needed) ---
        function updateSectionsOrderFromList() {
          const fragment = document.createDocumentFragment();
          reorderList.querySelectorAll("li").forEach((li) => {
            const sectionId = li.getAttribute("data-section-id");
            const sectionEl = document.getElementById(sectionId);
            if (sectionEl) {
              fragment.appendChild(sectionEl);
            } else {
              console.warn(`Section element not found for ID: ${sectionId}`);
            }
          });
          contentContainer.innerHTML = "";
          contentContainer.appendChild(fragment);
        }

        // --- LI Drag/Drop Handlers (No changes needed) ---
        function liDragStart(e) {
          if (e.target.classList.contains("delete-btn")) {
            e.preventDefault();
            return;
          }
          draggedLi = this;
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", this.dataset.sectionId);
          setTimeout(() => this.classList.add("dragging"), 0);
        }
        function liDragOver(e) {
          e.preventDefault();
          const targetLi = e.target.closest("li");
          if (!targetLi || targetLi === draggedLi) return;
          reorderList
            .querySelectorAll("li")
            .forEach((li) => li.classList.remove("drag-over"));
          targetLi.classList.add("drag-over");
          e.dataTransfer.dropEffect = "move";
        }
        function liDragEnter(e) {
          e.preventDefault();
        }
        function liDragLeave(e) {
          if (!reorderList.contains(e.relatedTarget)) {
            reorderList
              .querySelectorAll("li")
              .forEach((li) => li.classList.remove("drag-over"));
          }
        }
        function liDrop(e) {
          e.preventDefault();
          e.stopPropagation();
          const targetLi = e.target.closest("li");
          reorderList
            .querySelectorAll("li")
            .forEach((li) => li.classList.remove("drag-over"));
          if (targetLi && draggedLi !== targetLi) {
            const rect = targetLi.getBoundingClientRect();
            const offsetY = e.clientY - rect.top;
            const isAfter = offsetY > rect.height / 2;
            if (isAfter) {
              targetLi.parentNode.insertBefore(draggedLi, targetLi.nextSibling);
            } else {
              targetLi.parentNode.insertBefore(draggedLi, targetLi);
            }
            updateSectionsOrderFromList();
          }
        }
        function liDragEnd(e) {
          if (draggedLi) {
            draggedLi.classList.remove("dragging");
          }
          reorderList
            .querySelectorAll("li")
            .forEach((li) => li.classList.remove("drag-over"));
          draggedLi = null;
        }
        function addLiDragAndDropHandlers(li) {
          li.addEventListener("dragstart", liDragStart, false);
          li.addEventListener("dragover", liDragOver, false);
          li.addEventListener("dragenter", liDragEnter, false);
          li.addEventListener("dragleave", liDragLeave, false);
          li.addEventListener("drop", liDrop, false);
          li.addEventListener("dragend", liDragEnd, false);
        }

        // --- File Upload via Drag and Drop (No changes needed) ---
        function handleFileDrop(e) {
          unhighlightDropZone();
          let dt = e.dataTransfer;
          let files = dt.files;
          processFiles(files);
        }
        function highlightDropZone() {
          dropZone.classList.add("drag-over-page");
        }
        function unhighlightDropZone() {
          dropZone.classList.remove("drag-over-page");
        }
        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }
        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, preventDefaults, false);
          document.body.addEventListener(eventName, preventDefaults, false);
        });
        ["dragenter", "dragover"].forEach((eventName) =>
          dropZone.addEventListener(eventName, highlightDropZone, false)
        );
        ["dragleave", "drop"].forEach((eventName) =>
          dropZone.addEventListener(eventName, unhighlightDropZone, false)
        );
        dropZone.addEventListener("drop", handleFileDrop, false);

        // --- Deletion and Clear All Logic (No changes needed) ---
        function showConfirmation(actionType, data) {
          pendingAction = actionType;
          confirmBtn.classList.remove("delete", "clear", "warning");
          if (actionType === "delete") {
            itemToDelete = data;
            modalTitle.textContent = "Confirm Deletion";
            modalMessage.textContent = `Are you sure you want to delete the section "${data.fileName}"?`;
            confirmBtn.textContent = "Delete";
            confirmBtn.classList.add("delete");
          } else if (actionType === "clearAll") {
            modalTitle.textContent = "Confirm Clear All";
            modalMessage.textContent =
              "Are you sure you want to remove all loaded sections?";
            confirmBtn.textContent = "Clear All";
            confirmBtn.classList.add("warning");
          } else {
            return;
          }
          confirmationModal.showModal();
          confirmBtn.focus();
        }
        function closeConfirmation() {
          confirmationModal.close();
          pendingAction = null;
          itemToDelete = null;
        }
        function performConfirmedAction() {
          if (pendingAction === "delete" && itemToDelete) {
            const sectionElement = document.getElementById(
              itemToDelete.sectionId
            );
            if (sectionElement) sectionElement.remove();
            const listItem = reorderList.querySelector(
              `li[data-section-id="${itemToDelete.sectionId}"]`
            );
            if (listItem) listItem.remove();
            console.log(`Deleted section: ${itemToDelete.fileName}`);
          } else if (pendingAction === "clearAll") {
            contentContainer.innerHTML = "";
            reorderList.innerHTML = "";
            sectionCounter = 0;
            fileInput.value = null;
            console.log("Cleared all sections.");
          }
          closeConfirmation();
          updateUIState();
        }

        // --- Download Utility ---
        function downloadFile(filename, content, mimeType) {
          try {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a); // Required for Firefox
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          } catch (error) {
            displayError(`Failed to initiate download for "${filename}". Error: ${error.message}`);
          }
        }

        // --- Export Functions (Modified exportCombinedHtml) ---
        function exportCombinedHtml() {
            clearErrors();
            if (contentContainer.children.length === 0) {
                displayError("No content available to export as HTML.");
                return;
            }
            showLoading(true, "Exporting HTML...");
            try {
                // --> Get the page's main CSS styles
                let pageStyles = '';
                const styleElement = document.querySelector('head > style'); // Adjust selector if needed
                if (styleElement) {
                    pageStyles = styleElement.innerHTML;
                } else {
                    console.warn("Could not find main style element to copy for HTML export.");
                    // Optionally provide fallback minimal styles here if needed
                }
                // <-- End getting styles

                // Updated HTML structure with full styles
                const htmlPrefix = `<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>MergeMark Combined Content</title>\n  <style>\n    /* Copied styles from MergeMark page */\n    ${pageStyles}\n\n    /* Additional styles for exported view if needed */\n    body { padding: var(--container-padding, 2rem); background-color: white; } \n    .no-print { display: none !important; } /* Ensure controls etc. are hidden */ \n    .container { max-width: var(--max-content-width, 900px); margin: 0 auto; } /* Center content */
  </style>\n</head>\n<body>\n  <div class="container">\n    <h1>Combined Content</h1>\n`; // Added container div
                const htmlSuffix = "\n  </div>\n</body>\n</html>"; // Closed container div

                // Create a temporary div to get the correctly ordered HTML
                const tempDiv = document.createElement('div');
                const sections = contentContainer.querySelectorAll(".file-section");
                sections.forEach(section => {
                    tempDiv.appendChild(section.cloneNode(true)); // Use clones to avoid moving elements
                });

                const combinedHtmlContent = tempDiv.innerHTML;
                const fullHtml = htmlPrefix + combinedHtmlContent + htmlSuffix;

                downloadFile("MergeMark_Combined.html", fullHtml, "text/html;charset=utf-8");

            } catch (error) {
                 displayError(`An error occurred during HTML export. Error: ${error.message}`);
                 console.error("Error exporting HTML:", error); // Keep console log
            } finally {
                 showLoading(false);
            }
        }

        function exportCombinedMarkdown() {
          clearErrors();
          if (contentContainer.children.length === 0) {
            displayError("No content available to export as Markdown.");
            return;
          }
          showLoading(true, "Exporting Markdown...");
          try {
            let combinedMarkdown = `# MergeMark Combined Markdown\n\n`;
            const sections = contentContainer.querySelectorAll(".file-section");

            sections.forEach((section) => {
              const fileName = section.dataset.fileName || "Untitled Section";
              const rawContent = section.dataset.rawContent || "";

              combinedMarkdown += `## ${fileName}\n\n`;
              combinedMarkdown += rawContent;
              combinedMarkdown += `\n\n---\n\n`;
            });

            downloadFile("MergeMark_Combined.md", combinedMarkdown, "text/markdown;charset=utf-8");

          } catch (error) {
            displayError(`An error occurred during Markdown export. Error: ${error.message}`);
          } finally {
            showLoading(false);
          }
        }

        // --- Event Listeners ---
        fileInput.addEventListener("change", function () {
          if (fileInput.files.length > 0) {
            clearErrors();
            processFiles(fileInput.files);
          }
        });

        // --- REWRITTEN PDF Generation using jsPDF.text() ---
        generateButton.addEventListener("click", function () {
          // ---> THIS WILL BE REPLACED in the next step <--- 
          clearErrors();
          showLoading(true, "Generating PDF...");
          // OLD jsPDF.text() logic remains for now, but marked for replacement
          if (typeof jspdf === "undefined") { 
              displayError("Error: jsPDF library not loaded. Cannot generate PDF.");
              showLoading(false);
              return;
           }
          const { jsPDF } = jspdf;
          try {
             const doc = new jsPDF({
                orientation: "p",
                unit: "pt",
                format: "a4",
             });
             const pageHeight = doc.internal.pageSize.height;
             const pageWidth = doc.internal.pageSize.width;
             const margin = 40;
             const maxLineWidth = pageWidth - 2 * margin;
             const headerFontSize = 14;
             const bodyFontSize = 10;
             const defaultLineHeight = bodyFontSize * 1.2;
             const headerLineHeight = headerFontSize * 1.2;
             const sectionSpacing = defaultLineHeight * 1.5;
             let y = margin;

             function addWrappedText(text, fontSize, lineHeight, isBold = false) {
                if (y + lineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                doc.setFontSize(fontSize);
                doc.setFont(undefined, isBold ? "bold" : "normal");
                const lines = doc.splitTextToSize(text, maxLineWidth);
                lines.forEach((line) => {
                    if (y + lineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                    doc.text(line, margin, y);
                    y += lineHeight;
                });
            }
            const sections = contentContainer.querySelectorAll(".file-section");
            if (sections.length === 0) { 
                displayError("No content sections found to generate PDF.");
                showLoading(false);
                return;
             }
            sections.forEach((section, index) => {
                const headerText = section.dataset.fileName || `Section ${index + 1}`;
                if (index > 0) { y += sectionSpacing; }
                addWrappedText(headerText, headerFontSize, headerLineHeight, true);
                y += headerLineHeight * 0.3;
                const contentElement = section.querySelector("div") || section.querySelector("pre");
                const contentText = contentElement ? contentElement.innerText.trim() : "";
                if (contentText) {
                    addWrappedText(contentText, bodyFontSize, defaultLineHeight, false);
                }
             });
             // TEMPORARY placeholder alert
             alert("PDF generation needs update for images. Using text-only for now.");
             doc.save("MergeMark_Text_Report.pdf");
          } catch (error) { 
             displayError(`An error occurred while generating the PDF. Error: ${error.message}`);
             console.error("Error generating PDF with jsPDF:", error); 
           }
          finally { showLoading(false); }
          // ---> END PDF generation logic for this step <--- 
        });

        printButton.addEventListener("click", function () {
          clearErrors();
          window.print();
        });

        clearAllButton.addEventListener("click", function () {
          clearErrors();
          showConfirmation("clearAll");
        });

        exportHtmlButton.addEventListener("click", exportCombinedHtml);
        exportMdButton.addEventListener("click", exportCombinedMarkdown);

        contactLink.addEventListener("click", function (e) {
          e.preventDefault();
          contactDialog.showModal();
        });
        closeContactDialog.addEventListener("click", function () {
          contactDialog.close();
        });
        confirmBtn.addEventListener("click", performConfirmedAction);
        cancelBtn.addEventListener("click", closeConfirmation);
        closeConfirmationModal.addEventListener("click", closeConfirmation);

        helpLink.addEventListener("click", (e) => {
          e.preventDefault();
          helpDetails.open = !helpDetails.open;
          if (helpDetails.open) {
            helpDetails.scrollIntoView({ behavior: 'smooth' });
          }
        });

        updateUIState();
      });
    </script>
  </body>
</html>
