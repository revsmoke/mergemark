<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MergeMark - Combined Document to PDF</title>
    <link rel="stylesheet" href="archi.mergemark.css" />
    <script src="https://kit.fontawesome.com/b006b916ef.js" crossorigin="anonymous"></script>
  </head>
  <body>
    <div class="main-container">
      <nav class="breadcrumbs">
        
        <div class="breadcrumb-back-link">
            <a title="Archinet" href="/"><i class="fa-kit fa-archinet-logo"></i></a> <a href="/">Projects</a> / <a href="/help">Tools</a> / <a href="/mergemark">MergeMark</a>
        </div>
    
        <div class="no-print nav-actions">
          <a id="contactLink" href="#"><i class="fas fa-envelope"></i> Contact</a>
          <a href="#" id="helpLink"><i class="fa-solid fa-message-question"></i> Help</a>
          <a href="#" id="darkModeToggle"><i class="fas fa-moon"></i> Dark Mode</a>
        </div> 
        </nav>
    <header class="no-print page-header">
      <img src="mergemark_logo.svg" height="20" alt="MergeMark Logo" id="logo">
      <h1>MergeMark</h1>
      
    </header>
    <p id="intro" class="no-print">
      <strong>MergeMark</strong> combines multiple text or markdown files into a single document
      for easy reading, organization, and export. Upload files, arrange them, and export in your preferred format.
    </p>
    <div class="container">

      
      <div id="controlsContainer">
        <div class="controls no-print">
          <div class="file-input-container">
            <label for="fileInput" class="file-input-label">Select Files</label>
            <input
              type="file"
              id="fileInput"
              multiple
              accept=".txt,.md,text/plain,text/markdown"
            />
            <div id="dropZone" class="drop-zone no-print">
              <span>Drag & Drop Text or Markdown Files Here</span>
              <small>Accepted formats: .txt, .md</small>
            </div>
            <button id="clearAllButton" class="button warning" disabled>
              <i class="fas fa-trash-alt"></i> Clear All
            </button>
          </div>
          
          <div
            id="loadingIndicator"
            class="loading-indicator-container no-print"
          >
            <span>Generating PDF...</span>
            <span class="loading-indicator"></span>
          </div>
          
          <!-- Error Message Container -->
          <div id="errorMessages" class="error-container no-print"></div>
        </div>
        
        <div
          id="reorderContainer"
          class="document-section-reorder-container no-print"
        >
          <h3>Document Sections (Drag to Reorder)</h3>
          <div id="reorderPlaceholder">
            Upload or drop files to see sections here.
          </div>
          <ol id="document-section-reorder-list"></ol>
        </div>
      </div>

      <div
        id="actionsContainer"
        class="document-section-reorder-container no-print"
      >
        <h3>Export Options</h3>
        <div class="button-grid">
          <button id="printButton" class="button" disabled>
            <i class="fas fa-print"></i> Print Document
          </button>
          <button id="generateButton" class="button" disabled>
            <i class="fas fa-file-pdf"></i> Generate PDF (Text Only)
          </button>
          <button id="exportHtmlButton" class="button" disabled>
            <i class="fas fa-file-code"></i> Export Combined HTML
          </button>
          <button id="exportMdButton" class="button" disabled>
            <i class="fas fa-file-alt"></i> Export Combined Markdown
          </button>
        </div>
      </div>
      
      <div class="content-wrapper">
        <h2 class="content-title"><i class="fas fa-file-alt"></i> Document Preview</h2>
        <main id="content" class="content-scrollable"></main>
        <button id="backToTop" class="back-to-top" title="Back to top">
          <i class="fas fa-arrow-up"></i>
        </button>
      </div>
    </div>
  
      <dialog id="helpDialog" class="modal no-print">
        <button id="closeHelpDialog" class="modal-close"><i class="fas fa-times"></i></button>
        <div class="help-container">
          <h2 class="modal-title">Getting Started with MergeMark</h2>
          <p>
            Combine multiple text (.txt) or markdown (.md) files into a single
            document for easy reading, organization, and export.
          </p>
          <ol>
            <li>
              <strong>Upload Files:</strong> Click "Select Files" or drag & drop
              files.
            </li>
            <li>
              <strong>Reorder Content:</strong> Drag and drop items in the list
              to change their order.
            </li>
            <li>
              <strong>Remove Content:</strong> Click the "Delete" button next to
              any section.
            </li>
            <li>
              <strong>Clear All:</strong> Click "Clear All" to remove all files.
            </li>
            <li>
              <strong>Export Options:</strong>
              <ul>
                <li><strong>Print Document:</strong> Print or save as PDF with full formatting</li>
                <li><strong>Generate PDF (Text Only):</strong> Create a text-only PDF download</li>
                <li><strong>Export Combined HTML:</strong> Save as a standalone HTML file</li>
                <li><strong>Export Combined Markdown:</strong> Save as a markdown file</li>
              </ul>
            </li>
          </ol>
          <h2>Tips</h2>
          <div class="tip-box">
            <div class="tip-title">Markdown Support:</div>
            Preview shows formatted markdown, but PDF export is text only.
          </div>
          <div class="tip-box">
            <div class="tip-title">Text Files:</div>
            Text content is included in the PDF.
          </div>
          <div class="tip-box">
            <div class="tip-title">PDF Output:</div>
            The generated PDF uses standard fonts and basic layout for
            readability.
          </div>
          <div class="tip-box">
            <div class="tip-title">Images:</div>
            Images in markdown files are supported in the rendered preview and HTML export.
          </div>
          <footer class="footer">© 2025 MergeMark</footer>
        </div>
      </dialog>

    <dialog id="confirmationModal" class="modal no-print">
      <button id="closeConfirmationModal" class="modal-close"><i class="fas fa-times"></i></button>
      <div>
        <h3 id="modalTitle" class="modal-title">Confirm Action</h3>
        <p id="modalMessage" class="modal-message">Are you sure?</p>
        <div class="modal-actions">
          <button id="cancelBtn" class="button modal-cancel">Cancel</button>
          <button id="confirmBtn" class="button modal-confirm">Confirm</button>
        </div>
      </div>
    </dialog>

    <dialog id="contactDialog" class="modal no-print">
      <button id="closeContactDialog" class="modal-close"><i class="fas fa-times"></i></button>
      <div>
        <h3 id="modalTitle" class="modal-title">Contact Us</h3>
        <p id="modalMessage" class="modal-message">Please fill out the form below to contact us.</p>
        <!-- Add Contact Form -->
        <form id="contactForm">
          <div class="contact-form-group">
            <label for="contactName">Name:</label>
            <input type="text" id="contactName" name="contactName" required>
          </div>
          <div class="contact-form-group">
            <label for="contactEmail">Email:</label>
            <input type="email" id="contactEmail" name="contactEmail" required>
          </div>
          <div class="contact-form-group">
            <label for="contactSubject">Subject:</label>
            <input type="text" id="contactSubject" name="contactSubject" required>
          </div>
          <div class="contact-form-group">
            <label for="contactMessage">Message:</label>
            <textarea id="contactMessage" name="contactMessage" rows="4" required></textarea>
          </div>
          <div class="contact-form-actions">
            <button type="submit" class="button">Send Message</button>
          </div>
        </form>
        <!-- End Contact Form -->
      </div>
    </dialog>
    <!-- Toast Notification Container -->
    <div id="toast" class="toast"></div>

    <footer>
      <p>© 2025 MergeMark</p>
    </footer>
  </div>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
      integrity="sha512-qZvrmS2ekKPF2mSznTQsxqPgnpkI4DNTlrdUmTzrDgektczlKNRRhy5X5AAOnx5S09ydFYWWNSfcEqDTTHgtNA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="js/html2canvas.min.js"></script>
    <script defer>
      document.addEventListener("DOMContentLoaded", function () {
        // --- DOM Elements ---
        const fileInput = document.getElementById("fileInput");
        const contentContainer = document.getElementById("content");
        const generateButton = document.getElementById("generateButton");
        const darkModeToggle = document.getElementById("darkModeToggle");
        const toastElement = document.getElementById("toast");
        const backToTopButton = document.getElementById("backToTop");
        const printButton = document.getElementById("printButton");
        const clearAllButton = document.getElementById("clearAllButton");
        const exportHtmlButton = document.getElementById("exportHtmlButton");
        const exportMdButton = document.getElementById("exportMdButton");
        const reorderList = document.getElementById("document-section-reorder-list");
        const reorderContainer = document.getElementById("reorderContainer");
        const reorderPlaceholder = document.getElementById("reorderPlaceholder");
        const confirmationModal = document.getElementById("confirmationModal");
        const modalTitle = confirmationModal.querySelector(".modal-title");
        const modalMessage = confirmationModal.querySelector(".modal-message");
        const confirmBtn = document.getElementById("confirmBtn");
        const cancelBtn = document.getElementById("cancelBtn");
        const closeConfirmationModal = document.getElementById("closeConfirmationModal");
        const dropZone = document.getElementById("dropZone");
        const loadingIndicator = document.getElementById("loadingIndicator");
        const loadingIndicatorText = loadingIndicator.querySelector('span:first-child');
        const contactDialog = document.getElementById("contactDialog");
        const closeContactDialog = document.getElementById("closeContactDialog");
        const contactLink = document.getElementById("contactLink");
        const helpLink = document.getElementById("helpLink");
        const helpDialog = document.getElementById("helpDialog");
        const closeHelpDialog = document.getElementById("closeHelpDialog");
        const errorMessagesContainer = document.getElementById("errorMessages");

        // --- State Variables ---
        let draggedLi = null;
        let sectionCounter = 0;
        let pendingAction = null;
        let itemToDelete = null;

        // --- Utility Functions ---
        function showLoading(isLoading, actionText = "Processing...") {
          loadingIndicatorText.textContent = actionText;
          loadingIndicator.style.display = isLoading ? "inline-flex" : "none";
          generateButton.disabled = isLoading;
          printButton.disabled = isLoading;
          clearAllButton.disabled = isLoading;
          exportHtmlButton.disabled = isLoading;
          exportMdButton.disabled = isLoading;
          fileInput.disabled = isLoading;
          reorderList.style.pointerEvents = isLoading ? "none" : "auto";
          reorderList.style.opacity = isLoading ? 0.7 : 1;
        }
        function updateUIState() {
          const hasFiles = reorderList.children.length > 0;
          reorderContainer.style.display = "block";
          reorderPlaceholder.style.display = hasFiles ? "none" : "block";
          reorderList.style.display = hasFiles ? "block" : "none";
          generateButton.disabled = !hasFiles;
          clearAllButton.disabled = !hasFiles;
          printButton.disabled = !hasFiles;
          exportHtmlButton.disabled = !hasFiles;
          exportMdButton.disabled = !hasFiles;
        }

        function clearErrors() {
          errorMessagesContainer.innerHTML = '';
          errorMessagesContainer.style.display = 'none';
        }

        function displayError(message) {
          const errorElement = document.createElement('p');
          errorElement.className = 'error-message';
          errorElement.textContent = message;
          errorMessagesContainer.appendChild(errorElement);
          errorMessagesContainer.style.display = 'block';
          console.error("Error Displayed: ", message);
        }

        // --- NEW Image Handling Helpers ---

        // Fetches an image URL and converts it to a Base64 Data URL
        async function fetchImageAsBase64(url) {
            try {
                // Basic check for existing data URLs
                if (url.startsWith('data:image')) {
                    return url;
                }

                // Add timestamp to try bypassing cache if needed, though browser cache might still interfere
                // const cacheBusterUrl = url + (url.includes('?') ? '&' : '?') + '_=' + Date.now();

                const response = await fetch(url); // Use default cache behavior first

                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status} for URL: ${url}`);
                }
                const blob = await response.blob();

                // Ensure it's an image blob
                if (!blob.type.startsWith('image/')) {
                    throw new Error(`Fetched resource is not an image type (${blob.type}) for URL: ${url}`);
                }

                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = (error) => reject(new Error(`FileReader error for URL ${url}: ${error}`));
                    reader.readAsDataURL(blob);
                });
            } catch (error) {
                 // Log specific error but re-throw or return an indicator
                console.error(`Failed to fetch or convert image ${url}:`, error);
                 displayError(`Could not load image: ${url}. Reason: ${error.message}. It might be blocked by CORS or unavailable.`);
                return null; // Return null to indicate failure
            }
        }

        // Finds images within an element and updates their src to Base64
        async function processImagesInElement(element) {
            const images = element.querySelectorAll('img');
            const promises = [];

            images.forEach(img => {
                const originalSrc = img.getAttribute('src');
                 if (originalSrc && !originalSrc.startsWith('data:image')) {
                    // Create a promise for each image conversion
                     const promise = fetchImageAsBase64(originalSrc).then(base64Url => {
                        if (base64Url) {
                             img.src = base64Url; // Update the src attribute directly
                         } else {
                             // Optional: Handle failed images (e.g., show placeholder, remove img)
                             img.alt = `(Failed to load: ${img.alt || originalSrc})`;
                             // img.style.display = 'none'; // Or hide it
                         }
                    });
                    promises.push(promise);
                 }
            });

            // Wait for all image conversions for this element to settle
            await Promise.allSettled(promises);
         }

        // --- File Handling (Modified) ---
        function processFiles(files) {
          showLoading(true, "Loading & Processing Files..."); // Updated text
          clearErrors();

          contentContainer.innerHTML = "";
          reorderList.innerHTML = "";
          sectionCounter = 0;
          let fileArray = Array.from(files);
          const skippedFiles = [];
          const validFiles = fileArray.filter(file => {
                const isValid = file.type === "text/plain" ||
                       file.type === "text/markdown" ||
                       file.name.toLowerCase().endsWith(".txt") ||
                       file.name.toLowerCase().endsWith(".md");
                if (!isValid) {
                    skippedFiles.push(file.name);
                }
                return isValid;
           });
           if (skippedFiles.length > 0) { 
               displayError(`Skipped ${skippedFiles.length} file(s) due to invalid type (only .txt or .md allowed): ${skippedFiles.join(', ')}`);
            }
           if (validFiles.length === 0) { 
                showLoading(false);
                updateUIState();
                return;
            }
          // Clear containers before processing starts
          contentContainer.innerHTML = ""; 
          reorderList.innerHTML = "";
          sectionCounter = 0;

           validFiles.sort((a, b) => a.name.localeCompare(b.name));
           // let filesProcessed = 0; // Replaced by Promise tracking
           const allFileProcessingPromises = []; // Array to hold promises for each file's processing

          validFiles.forEach((file) => {
            // Wrap the entire file processing in a promise
             const filePromise = new Promise(async (resolveFile, rejectFile) => {
                 const reader = new FileReader();

                 reader.onload = async function (e) { // Make onload async
                    const sectionId = "section_" + sectionCounter++; // Generate ID early for potential error cleanup
                    try {
                        const fileContent = e.target.result;
                        const section = document.createElement("section");
                        section.className = "file-section";
                        section.id = sectionId;
                        section.dataset.rawContent = fileContent;
                        section.dataset.fileName = file.name;

                        const header = document.createElement("h2");
                        header.textContent = file.name;
                        section.appendChild(header);

                        let contentElement; // To hold the div or pre

                        if (file.name.toLowerCase().endsWith(".md")) {
                            const contentDiv = document.createElement("div");
                            contentDiv.innerHTML = marked.parse(fileContent); // Initial parse
                            section.appendChild(contentDiv);
                            contentElement = contentDiv;

                            // --> Process images AFTER initial parse
                             showLoading(true, `Processing images in ${file.name}...`); // Give feedback
                            await processImagesInElement(contentDiv);
                             showLoading(true, "Loading & Processing Files..."); // Reset loading text
                            // <-- End image processing

                        } else {
                            const pre = document.createElement("pre");
                            pre.textContent = fileContent;
                            section.appendChild(pre);
                            contentElement = pre;
                        }
                        contentContainer.appendChild(section);

                        // Create list item... 
                        const li = document.createElement("li");
                        li.setAttribute("data-section-id", sectionId);
                        li.setAttribute("draggable", true);
                        li.setAttribute("tabindex", "0");
                        
                        const fileNameSpan = document.createElement("span");
                        fileNameSpan.textContent = file.name;
                        fileNameSpan.style.overflow = "hidden";
                        fileNameSpan.style.textOverflow = "ellipsis";
                        fileNameSpan.style.whiteSpace = "nowrap";
                        fileNameSpan.style.marginRight = "10px";
                        
                        // Create scroll to section button
                        const scrollBtn = document.createElement("button");
                        scrollBtn.className = "scroll-to-section";
                        scrollBtn.type = "button";
                        scrollBtn.title = "Scroll to section";
                        const scrollIcon = document.createElement("i");
                        scrollIcon.className = "fas fa-arrow-down";
                        scrollBtn.appendChild(scrollIcon);
                        scrollBtn.addEventListener("click", (event) => {
                          event.stopPropagation();
                          const section = document.getElementById(sectionId);
                          if (section) {
                            section.scrollIntoView({ behavior: 'smooth', block: 'start' });
                            // Highlight the section briefly
                            section.classList.add("highlight-section");
                            setTimeout(() => {
                              section.classList.remove("highlight-section");
                            }, 1500);
                          }
                        });
                        
                        const deleteBtn = document.createElement("button");
                        deleteBtn.className = "delete-btn";
                        //.textContent = "Delete";
                        deleteBtn.innerHTML = '<i class="fa-solid fa-trash-can"></i>';
                        deleteBtn.type = "button";
                        deleteBtn.addEventListener("click", (event) => {
                          event.stopPropagation();
                          showConfirmation("delete", { sectionId: sectionId, fileName: file.name });
                        });
                        
                        // Add buttons to list item
                        const buttonContainer = document.createElement("div");
                        buttonContainer.className = "list-item-buttons";
                        buttonContainer.appendChild(scrollBtn);
                        buttonContainer.appendChild(deleteBtn);
                        
                        li.appendChild(fileNameSpan);
                        li.appendChild(buttonContainer);
                        addLiDragAndDropHandlers(li);
                        reorderList.appendChild(li);
                        resolveFile(); // Resolve the promise for this file

                    } catch (error) {
                         displayError(`Error processing file "${file.name}": ${error.message}`);
                         const problemSection = document.getElementById(sectionId);
                         if (problemSection) problemSection.remove();
                         // Don't remove LI here as it might not exist yet
                         rejectFile(error); // Reject the promise for this file
                     }
                 };

                 reader.onerror = function (e) {
                     const errorMsg = `Error reading file "${file.name}". Details: ${e.target.error || 'Unknown read error'}`;
                     displayError(errorMsg);
                     rejectFile(new Error(errorMsg)); // Reject the promise for this file
                 };

                 reader.readAsText(file);
             }); // End of filePromise

            allFileProcessingPromises.push(filePromise);

          }); // End loop through validFiles

          // Wait for all files to be processed (including image conversion)
          Promise.allSettled(allFileProcessingPromises).then(() => {
              showLoading(false);
              updateSectionsOrderFromList(); // Update order based on LI elements
              updateUIState();
              console.log("All files processed.");
           }).catch(error => {
              // This catch might be redundant if individual errors are handled, but good for safety
              console.error("Error during batch file processing:", error);
              showLoading(false); // Ensure loading is hidden on batch error
              updateUIState();
          });
        } // End processFiles function

        // --- Reordering Logic (No changes needed) ---
        function updateSectionsOrderFromList() {
          const fragment = document.createDocumentFragment();
          reorderList.querySelectorAll("li").forEach((li) => {
            const sectionId = li.getAttribute("data-section-id");
            const sectionEl = document.getElementById(sectionId);
            if (sectionEl) {
              fragment.appendChild(sectionEl);
            } else {
              console.warn(`Section element not found for ID: ${sectionId}`);
            }
          });
          contentContainer.innerHTML = "";
          contentContainer.appendChild(fragment);
        }

        // --- LI Drag/Drop Handlers (No changes needed) ---
        function liDragStart(e) {
          if (e.target.classList.contains("delete-btn")) {
            e.preventDefault();
            return;
          }
          draggedLi = this;
          e.dataTransfer.effectAllowed = "move";
          e.dataTransfer.setData("text/plain", this.dataset.sectionId);
          setTimeout(() => this.classList.add("dragging"), 0);
        }
        function liDragOver(e) {
          e.preventDefault();
          const targetLi = e.target.closest("li");
          if (!targetLi || targetLi === draggedLi) return;
          reorderList
            .querySelectorAll("li")
            .forEach((li) => li.classList.remove("drag-over"));
          targetLi.classList.add("drag-over");
          e.dataTransfer.dropEffect = "move";
        }
        function liDragEnter(e) {
          e.preventDefault();
        }
        function liDragLeave(e) {
          if (!reorderList.contains(e.relatedTarget)) {
            reorderList
              .querySelectorAll("li")
              .forEach((li) => li.classList.remove("drag-over"));
          }
        }
        function liDrop(e) {
          e.preventDefault();
          e.stopPropagation();
          const targetLi = e.target.closest("li");
          reorderList
            .querySelectorAll("li")
            .forEach((li) => li.classList.remove("drag-over"));
          if (targetLi && draggedLi !== targetLi) {
            const rect = targetLi.getBoundingClientRect();
            const offsetY = e.clientY - rect.top;
            const isAfter = offsetY > rect.height / 2;
            if (isAfter) {
              targetLi.parentNode.insertBefore(draggedLi, targetLi.nextSibling);
            } else {
              targetLi.parentNode.insertBefore(draggedLi, targetLi);
            }
            updateSectionsOrderFromList();
          }
        }
        function liDragEnd(e) {
          if (draggedLi) {
            draggedLi.classList.remove("dragging");
          }
          reorderList
            .querySelectorAll("li")
            .forEach((li) => li.classList.remove("drag-over"));
          draggedLi = null;
        }
        function addLiDragAndDropHandlers(li) {
          li.addEventListener("dragstart", liDragStart, false);
          li.addEventListener("dragover", liDragOver, false);
          li.addEventListener("dragenter", liDragEnter, false);
          li.addEventListener("dragleave", liDragLeave, false);
          li.addEventListener("drop", liDrop, false);
          li.addEventListener("dragend", liDragEnd, false);
        }

        // --- File Upload via Drag and Drop (No changes needed) ---
        function handleFileDrop(e) {
          unhighlightDropZone();
          let dt = e.dataTransfer;
          let files = dt.files;
          processFiles(files);
        }
        function highlightDropZone() {
          dropZone.classList.add("drag-over-page");
        }
        function unhighlightDropZone() {
          dropZone.classList.remove("drag-over-page");
        }
        function preventDefaults(e) {
          e.preventDefault();
          e.stopPropagation();
        }
        ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
          dropZone.addEventListener(eventName, preventDefaults, false);
          document.body.addEventListener(eventName, preventDefaults, false);
        });
        ["dragenter", "dragover"].forEach((eventName) =>
          dropZone.addEventListener(eventName, highlightDropZone, false)
        );
        ["dragleave", "drop"].forEach((eventName) =>
          dropZone.addEventListener(eventName, unhighlightDropZone, false)
        );
        dropZone.addEventListener("drop", handleFileDrop, false);

        // --- Deletion and Clear All Logic (No changes needed) ---
        function showConfirmation(actionType, data) {
          pendingAction = actionType;
          confirmBtn.classList.remove("delete", "clear", "warning");
          if (actionType === "delete") {
            itemToDelete = data;
            modalTitle.textContent = "Confirm Deletion";
            modalMessage.textContent = `Are you sure you want to delete the section "${data.fileName}"?`;
            confirmBtn.textContent = "Delete";
            confirmBtn.classList.add("delete");
          } else if (actionType === "clearAll") {
            modalTitle.textContent = "Confirm Clear All";
            modalMessage.textContent =
              "Are you sure you want to remove all loaded sections?";
            confirmBtn.textContent = "Clear All";
            confirmBtn.classList.add("warning");
          } else {
            return;
          }
          confirmationModal.showModal();
          confirmBtn.focus();
        }
        function closeConfirmation() {
          confirmationModal.close();
          pendingAction = null;
          itemToDelete = null;
        }
        function performConfirmedAction() {
          if (pendingAction === "delete" && itemToDelete) {
            const sectionElement = document.getElementById(
              itemToDelete.sectionId
            );
            if (sectionElement) sectionElement.remove();
            const listItem = reorderList.querySelector(
              `li[data-section-id="${itemToDelete.sectionId}"]`
            );
            if (listItem) listItem.remove();
            console.log(`Deleted section: ${itemToDelete.fileName}`);
          } else if (pendingAction === "clearAll") {
            contentContainer.innerHTML = "";
            reorderList.innerHTML = "";
            sectionCounter = 0;
            fileInput.value = null;
            console.log("Cleared all sections.");
          }
          closeConfirmation();
          updateUIState();
        }

        // --- Download Utility ---
        function downloadFile(filename, content, mimeType) {
          try {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            document.body.appendChild(a); // Required for Firefox
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
          } catch (error) {
            displayError(`Failed to initiate download for "${filename}". Error: ${error.message}`);
          }
        }

        // --- Export Functions (Modified exportCombinedHtml) ---
        function exportCombinedHtml() {
            clearErrors();
            if (contentContainer.children.length === 0) {
                displayError("No content available to export as HTML.");
                return;
            }
            showLoading(true, "Exporting HTML...");
            try {
                // --> Get the page's main CSS styles
                let pageStyles = '';
                const styleElement = document.querySelector('head > style'); // Adjust selector if needed
                if (styleElement) {
                    pageStyles = styleElement.innerHTML;
                } else {
                    console.warn("Could not find main style element to copy for HTML export.");
                    // Optionally provide fallback minimal styles here if needed
                }
                // <-- End getting styles

                // Updated HTML structure with full styles
                const htmlPrefix = `<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>MergeMark Combined Content</title>\n  <style>\n    /* Copied styles from MergeMark page */\n    ${pageStyles}\n\n    /* Additional styles for exported view if needed */\n    body { padding: var(--container-padding, 2rem); background-color: white; } \n    .no-print { display: none !important; } /* Ensure controls etc. are hidden */ \n    .container { max-width: var(--max-content-width, 900px); margin: 0 auto; } /* Center content */
  </style>\n</head>\n<body>\n  <div class="container">\n    <h1>Combined Content</h1>\n`; // Added container div
                const htmlSuffix = "\n  </div>\n</body>\n</html>"; // Closed container div

                // Create a temporary div to get the correctly ordered HTML
                const tempDiv = document.createElement('div');
                const sections = contentContainer.querySelectorAll(".file-section");
                sections.forEach(section => {
                    tempDiv.appendChild(section.cloneNode(true)); // Use clones to avoid moving elements
                });

                const combinedHtmlContent = tempDiv.innerHTML;
                const fullHtml = htmlPrefix + combinedHtmlContent + htmlSuffix;

                downloadFile("MergeMark_Combined.html", fullHtml, "text/html;charset=utf-8");

            } catch (error) {
                 displayError(`An error occurred during HTML export. Error: ${error.message}`);
                 console.error("Error exporting HTML:", error); // Keep console log
            } finally {
                 showLoading(false);
            }
        }

        function exportCombinedMarkdown() {
          clearErrors();
          if (contentContainer.children.length === 0) {
            displayError("No content available to export as Markdown.");
            return;
          }
          showLoading(true, "Exporting Markdown...");
          try {
            let combinedMarkdown = `# MergeMark Combined Markdown\n\n`;
            const sections = contentContainer.querySelectorAll(".file-section");

            sections.forEach((section) => {
              const fileName = section.dataset.fileName || "Untitled Section";
              const rawContent = section.dataset.rawContent || "";

              combinedMarkdown += `## ${fileName}\n\n`;
              combinedMarkdown += rawContent;
              combinedMarkdown += `\n\n---\n\n`;
            });

            downloadFile("MergeMark_Combined.md", combinedMarkdown, "text/markdown;charset=utf-8");

          } catch (error) {
            displayError(`An error occurred during Markdown export. Error: ${error.message}`);
          } finally {
            showLoading(false);
          }
        }

        // --- Event Listeners ---
        fileInput.addEventListener("change", function () {
          if (fileInput.files.length > 0) {
            clearErrors();
            processFiles(fileInput.files);
          }
        });

        // --- REWRITTEN PDF Generation using jsPDF.text() ---
        generateButton.addEventListener("click", function () {
          // ---> THIS WILL BE REPLACED in the next step <--- 
          clearErrors();
          showLoading(true, "Generating PDF...");
          // OLD jsPDF.text() logic remains for now, but marked for replacement
          if (typeof jspdf === "undefined") { 
              displayError("Error: jsPDF library not loaded. Cannot generate PDF.");
              showLoading(false);
              return;
           }
          const { jsPDF } = jspdf;
          try {
             const doc = new jsPDF({
                orientation: "p",
                unit: "pt",
                format: "a4",
             });
             const pageHeight = doc.internal.pageSize.height;
             const pageWidth = doc.internal.pageSize.width;
             const margin = 40;
             const maxLineWidth = pageWidth - 2 * margin;
             const headerFontSize = 14;
             const bodyFontSize = 10;
             const defaultLineHeight = bodyFontSize * 1.2;
             const headerLineHeight = headerFontSize * 1.2;
             const sectionSpacing = defaultLineHeight * 1.5;
             let y = margin;

             function addWrappedText(text, fontSize, lineHeight, isBold = false) {
                if (y + lineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                doc.setFontSize(fontSize);
                doc.setFont(undefined, isBold ? "bold" : "normal");
                const lines = doc.splitTextToSize(text, maxLineWidth);
                lines.forEach((line) => {
                    if (y + lineHeight > pageHeight - margin) { doc.addPage(); y = margin; }
                    doc.text(line, margin, y);
                    y += lineHeight;
                });
            }
            const sections = contentContainer.querySelectorAll(".file-section");
            if (sections.length === 0) { 
                displayError("No content sections found to generate PDF.");
                showLoading(false);
                return;
             }
            sections.forEach((section, index) => {
                const headerText = section.dataset.fileName || `Section ${index + 1}`;
                if (index > 0) { y += sectionSpacing; }
                addWrappedText(headerText, headerFontSize, headerLineHeight, true);
                y += headerLineHeight * 0.3;
                const contentElement = section.querySelector("div") || section.querySelector("pre");
                const contentText = contentElement ? contentElement.innerText.trim() : "";
                if (contentText) {
                    addWrappedText(contentText, bodyFontSize, defaultLineHeight, false);
                }
             });
             // TEMPORARY placeholder alert
             alert("PDF generation needs update for images. Using text-only for now.");
             doc.save("MergeMark_Text_Report.pdf");
          } catch (error) { 
             displayError(`An error occurred while generating the PDF. Error: ${error.message}`);
             console.error("Error generating PDF with jsPDF:", error); 
           }
          finally { showLoading(false); }
          // ---> END PDF generation logic for this step <--- 
        });

        printButton.addEventListener("click", function () {
          clearErrors();
          window.print();
        });

        clearAllButton.addEventListener("click", function () {
          clearErrors();
          showConfirmation("clearAll");
        });

        exportHtmlButton.addEventListener("click", exportCombinedHtml);
        exportMdButton.addEventListener("click", exportCombinedMarkdown);

        contactLink.addEventListener("click", function (e) {
          e.preventDefault();
          contactDialog.showModal();
        });
        closeContactDialog.addEventListener("click", function () {
          contactDialog.close();
        });

        helpLink.addEventListener("click", (e) => {
          e.preventDefault();
          helpDialog.showModal();
        });
        
        closeHelpDialog.addEventListener("click", () => {
          helpDialog.close();
        });
        
        // Allow clicking outside of help dialog to close it
        helpDialog.addEventListener("click", (e) => {
          const dialogDimensions = helpDialog.getBoundingClientRect();
          if (
            e.clientX < dialogDimensions.left ||
            e.clientX > dialogDimensions.right ||
            e.clientY < dialogDimensions.top ||
            e.clientY > dialogDimensions.bottom
          ) {
            helpDialog.close();
          }
        });

        confirmBtn.addEventListener("click", performConfirmedAction);
        cancelBtn.addEventListener("click", closeConfirmation);
        closeConfirmationModal.addEventListener("click", closeConfirmation);

        updateUIState();
        
        // --- Dark Mode Toggle ---
        function toggleDarkMode() {
          document.body.classList.toggle('dark-mode');
          
          // Save preference to localStorage
          if (document.body.classList.contains('dark-mode')) {
            localStorage.setItem('mergemark-theme', 'dark');
            darkModeToggle.querySelector('i').classList.remove('fa-moon');
            darkModeToggle.querySelector('i').classList.add('fa-sun');
          } else {
            localStorage.setItem('mergemark-theme', 'light');
            darkModeToggle.querySelector('i').classList.remove('fa-sun');
            darkModeToggle.querySelector('i').classList.add('fa-moon');
          }
        }
        
        // Check for saved theme preference
        const savedTheme = localStorage.getItem('mergemark-theme');
        if (savedTheme === 'dark') {
          document.body.classList.add('dark-mode');
          darkModeToggle.querySelector('i').classList.remove('fa-moon');
          darkModeToggle.querySelector('i').classList.add('fa-sun');
        }
        
        // Add event listener for dark mode toggle
        darkModeToggle.addEventListener('click', function(e) {
          e.preventDefault();
          toggleDarkMode();
        });
        
        // --- Toast Notification Function ---
        function showToast(message, duration = 3000) {
          toastElement.textContent = message;
          toastElement.classList.add('show');
          
          setTimeout(() => {
            toastElement.classList.remove('show');
          }, duration);
        }
        
        // Add file type indicators to section headers
        function addFileTypeIndicator(fileName, headerElement) {
          const fileExt = fileName.split('.').pop().toLowerCase();
          const fileTag = document.createElement('span');
          fileTag.classList.add('file-tag');
          
          if (fileExt === 'md') {
            fileTag.textContent = 'MARKDOWN';
          } else {
            fileTag.textContent = 'TEXT';
          }
          
          headerElement.appendChild(fileTag);
        }
        
        // Enhance the file processing with animations
        const originalProcessFiles = processFiles;
        processFiles = function(files) {
          // Add visual feedback when starting to process files
          showToast(`Processing ${files.length} file(s)...`);
          
          // Call the original function
          originalProcessFiles(files);
        };
        
        // Add file type tags to section headers
        const originalUpdateSectionsOrderFromList = updateSectionsOrderFromList;
        updateSectionsOrderFromList = function() {
          originalUpdateSectionsOrderFromList();
          
          // Add file type indicators to headers if they don't already have them
          document.querySelectorAll('.file-section h2').forEach(header => {
            if (!header.querySelector('.file-tag')) {
              const fileName = header.textContent;
              addFileTypeIndicator(fileName, header);
            }
          });
        };
        
        // Add enhanced feedback for exports
        exportHtmlButton.addEventListener('click', function() {
          const originalExportHtml = exportCombinedHtml;
          showToast('Preparing HTML export...');
          setTimeout(() => {
            exportCombinedHtml();
            setTimeout(() => {
              showToast('HTML export complete!', 2000);
            }, 500);
          }, 300);
        });
        
        exportMdButton.addEventListener('click', function() {
          showToast('Preparing Markdown export...');
          setTimeout(() => {
            exportCombinedMarkdown();
            setTimeout(() => {
              showToast('Markdown export complete!', 2000);
            }, 500);
          }, 300);
        });
        
        // Implement back to top button functionality
        backToTopButton.addEventListener('click', function() {
          contentContainer.scrollTo({
            top: 0,
            behavior: 'smooth'
          });
        });
        
        // Show/hide back to top button based on scroll position
        contentContainer.addEventListener('scroll', function() {
          if (contentContainer.scrollTop > 300) {
            backToTopButton.classList.add('visible');
          } else {
            backToTopButton.classList.remove('visible');
          }
        });
      });
    </script>
  </body>
</html>